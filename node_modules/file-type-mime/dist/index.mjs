function getUint16(buffer, offset = 0) {
  const view = getBufferView(buffer, offset, 2);
  return view.getUint16(0, true);
}
function getUint32(buffer, offset = 0) {
  const view = getBufferView(buffer, offset, 4);
  return view.getUint32(0, true);
}
function getString(buffer, offset = 0, length = buffer.byteLength) {
  const slice = buffer.slice(offset, offset + length);
  return decoder.decode(new Uint8Array(slice));
}
function compareBytes(source, sample, offset = 0) {
  if (source.length < sample.length + offset) {
    return false;
  }
  for (const [i, element] of sample.entries()) {
    if (element === null)
      continue;
    if (element !== source[i + offset]) {
      return false;
    }
  }
  return true;
}
function getBufferView(buffer, offset, length) {
  const slice = buffer.slice(offset, offset + length);
  return new DataView(new Uint8Array(slice).buffer);
}
const decoder = new TextDecoder("utf8");

const signatures = [
  [
    "db",
    "application/vnd.sqlite3",
    [
      83,
      81,
      76,
      105,
      116,
      101,
      32,
      102,
      111,
      114,
      109,
      97,
      116,
      32,
      51,
      0
    ]
  ],
  ["woff", "font/woff", [119, 79, 70, 70]],
  ["woff2", "font/woff2", [119, 79, 70, 50]],
  ["bmp", "image/bmp", [66, 77]],
  ["gif", "image/gif", [71, 73, 70, 56, 55, 97]],
  ["gif", "image/gif", [71, 73, 70, 56, 57, 97]],
  [
    "heic",
    "image/heic",
    [102, 116, 121, 112, 104, 101, 105],
    { offset: 4 }
  ],
  ["heic", "image/heic", [102, 116, 121, 112, 109], { offset: 4 }],
  ["ico", "image/x-icon", [0, 0, 1, 0]],
  ["jpg", "image/jpeg", [255, 216, 255]],
  ["pdf", "application/pdf", [37, 80, 68, 70, 45]],
  ["png", "image/png", [137, 80, 78, 71, 13, 10, 26, 10]],
  ["7z", "application/x-7z-compressed", [55, 122, 188, 175, 39, 28]],
  [
    "rar",
    "application/x-rar-compressed",
    [82, 97, 114, 33, 26, 7, 0]
  ],
  [
    "rar",
    "application/x-rar-compressed",
    [82, 97, 114, 33, 26, 7, 1, 0]
  ],
  ["rtf", "application/rtf", [123, 92, 114, 116, 102, 49]],
  ["bz2", "application/x-bzip2", [66, 90, 104]],
  ["gz", "application/gzip", [31, 139]],
  [
    "tar",
    "application/x-tar",
    [117, 115, 116, 97, 114, 0, 48, 48],
    { offset: 257 }
  ],
  [
    "tar",
    "application/x-tar",
    [117, 115, 116, 97, 114, 32, 32, 0],
    { offset: 257 }
  ],
  ["tif", "image/tiff", [73, 73, 42, 0]],
  ["tiff", "image/tiff", [77, 77, 0, 42]],
  ["zip", "application/zip", [80, 75, 3, 4], { exact: false }],
  ["zip", "application/zip", [80, 75, 5, 6]],
  ["mp3", "audio/mp3", [255, 251]],
  ["mp3", "audio/mp3", [255, 243]],
  ["mp3", "audio/mp3", [255, 242]],
  ["mp3", "audio/mp3", [73, 68, 51]],
  [
    "mp4",
    "video/mp4",
    [102, 116, 121, 112, 105, 115, 111, 109],
    { offset: 4 }
  ],
  [
    "avi",
    "video/x-msvideo",
    [82, 73, 70, 70, null, null, null, null, 65, 86, 73, 32]
  ],
  [
    "wav",
    "audio/wav",
    [82, 73, 70, 70, null, null, null, null, 87, 65, 86, 69]
  ],
  [
    "ogx",
    "application/ogg",
    [79, 103, 103, 83],
    { exact: false },
    [
      ["oga", "audio/ogg", [127, 70, 76, 65, 67], { offset: 28 }],
      [
        "ogg",
        "audio/ogg",
        [1, 118, 111, 114, 98, 105, 115],
        { offset: 28 }
      ],
      [
        "ogm",
        "video/ogg",
        [1, 118, 105, 100, 101, 111, 0],
        { offset: 28 }
      ],
      [
        "ogv",
        "video/ogg",
        [128, 116, 104, 101, 111, 114, 97],
        { offset: 28 }
      ]
    ]
  ],
  [
    "webp",
    "image/webp",
    [82, 73, 70, 70, null, null, null, null, 87, 69, 66, 80]
  ],
  ["psd", "image/vnd.adobe.photoshop", [56, 66, 80, 83]],
  ["flac", "audio/x-flac", [102, 76, 97, 67]],
  ["wasm", "application/wasm", [0, 97, 115, 109]],
  [
    "deb",
    "application/x-deb",
    [33, 60, 97, 114, 99, 104, 62, 10]
  ],
  ["exe", "application/x-msdownload", [77, 90]],
  ["exe", "application/x-msdownload", [90, 77]],
  ["class", "application/java-vm", [202, 254, 186, 190]]
];

function isText(data) {
  for (let i = 0; i < data.length; i++) {
    try {
      const code = data.charCodeAt(i);
      if (code === 65533 || code <= 8) {
        return false;
      }
    } catch {
      return false;
    }
  }
  return true;
}
function parseTxtLikeFiles(buffer) {
  try {
    const data = getString(buffer);
    if (!isText(data)) {
      return void 0;
    }
    try {
      JSON.parse(data);
      return { ext: "json", mime: "application/json" };
    } catch {
      return { ext: "txt", mime: "text/plain" };
    }
  } catch {
    return void 0;
  }
}

function getUpperLimit(signatures) {
  return flatten(signatures).map(([_ext, _mime, sample, { offset = 0 } = {}]) => sample.length + offset).reduce((lim, val) => val > lim ? val : lim, 0);
}
function flatten(signatures) {
  return signatures.flatMap(
    ([ext, mime, bytes, options = {}, subSignatures = []]) => [
      [ext, mime, bytes, options],
      ...subSignatures
    ]
  );
}
function findMatches(signatures, { ext, mime }) {
  if (!(ext || mime))
    return [];
  return flatten(signatures).filter(
    (signature) => signature[0] === ext || signature[1] === mime
  );
}

function parseZipLikeFiles(buffer, result) {
  const size = getUint16(buffer, 26);
  const name = getString(buffer, 30, size);
  const [identifier] = name.split("/");
  const xmlFormat = name.endsWith(".xml");
  if (identifier === "META-INF") {
    return {
      ext: "jar",
      mime: "application/java-archive"
    };
  }
  if (identifier === "ppt" && xmlFormat) {
    return {
      ext: "pptx",
      mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
    };
  }
  if (identifier === "word" && xmlFormat) {
    return {
      ext: "docx",
      mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    };
  }
  if (identifier === "xl" && xmlFormat) {
    return {
      ext: "xlsx",
      mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    };
  }
  if (identifier === "mimetype") {
    return parseOpenDocumentFile(buffer, size) ?? result;
  }
  return result;
}
function parseOpenDocumentFile(buffer, offset) {
  const compressedSize = getUint32(buffer, 18);
  const uncompressedSize = getUint32(buffer, 22);
  const extraFieldLength = getUint16(buffer, 28);
  if (compressedSize === uncompressedSize) {
    const mime = getString(
      buffer,
      30 + offset + extraFieldLength,
      compressedSize
    );
    if (mime === "application/vnd.oasis.opendocument.presentation") {
      return {
        ext: "odp",
        mime
      };
    }
    if (mime === "application/vnd.oasis.opendocument.spreadsheet") {
      return {
        ext: "ods",
        mime
      };
    }
    if (mime === "application/vnd.oasis.opendocument.text") {
      return {
        ext: "odt",
        mime
      };
    }
    if (mime === "application/epub+zip") {
      return {
        ext: "epub",
        mime
      };
    }
  }
  return void 0;
}

const UPPER_LIMIT = getUpperLimit(signatures);
function parse(buffer, { extra = false, hint } = {}) {
  const bytes = new Uint8Array(buffer.slice(0, UPPER_LIMIT));
  if (hint) {
    const matches = findMatches(signatures, hint);
    if (matches.length > 0) {
      const result2 = parseBytes(bytes, matches);
      if (result2 !== void 0) {
        return result2;
      }
    }
  }
  const result = parseBytes(bytes, signatures);
  if (result) {
    return result;
  }
  if (extra) {
    return parseExtraTypes(buffer);
  }
  return void 0;
}
function parseBytes(bytes, signatures) {
  for (const [
    ext,
    mime,
    sample,
    { exact = true, offset = 0 } = {},
    subSignatures = []
  ] of signatures) {
    if (compareBytes(bytes, sample, offset)) {
      if (ext === "zip" && !exact) {
        return parseZipLikeFiles(bytes.buffer, { ext, mime });
      }
      if (!exact && subSignatures.length) {
        for (const [ext2, mime2, sample2, { offset: offset2 = 0 } = {}] of subSignatures) {
          if (compareBytes(bytes, sample2, offset2)) {
            return { ext: ext2, mime: mime2 };
          }
        }
      }
      return { ext, mime };
    }
  }
  return void 0;
}
function parseExtraTypes(buffer) {
  return parseTxtLikeFiles(buffer);
}

export { parse };
